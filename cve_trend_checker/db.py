#   Copyright (C) 2022 MIT
#   Author: Kha Tran
#   Title: Fresher Software Engineer


"""
    CVE Trend Checker's Databae System source code
"""
from __future__ import annotations
from asyncio import subprocess


import aiohttp
import logging
import os
import sqlite3
import subprocess

from typing import Any

from async_p import RateLimiter, run_coroutine
from date import get_cur_date, get_cur_date_non_iso
from log import LOGGER
from report import Report


logging.basicConfig(level=logging.DEBUG)


#   Database PATH locations
DATABASE_LOCATION_DEFAULT: str = os.path.join(
    os.path.expanduser("~"), ".cache", "ctc-database")
DATABASE_LOCATION_BACKUP: str = os.path.join(
    os.path.expanduser("~"), ".cache", "ctc-backup")
DB_NAME: str = "scan.db"
IMAGE_LOCATION_DEFAULT: str = os.path.join(os.path.dirname(
    os.path.abspath(__file__)), "plot", get_cur_date_non_iso())


class DB:
    """
        Scans from report files and fetch each CVE from APIs 
    """

    CACHE_DIR: str = DATABASE_LOCATION_DEFAULT
    BACKUP_CACHE_DIR: str = DATABASE_LOCATION_BACKUP
    IMAGE_DIR: str = IMAGE_LOCATION_DEFAULT
    REDHAT_API: str = "https://access.redhat.com/hydra/rest/securitydata/cve/{}.json"
    NVD_API: str = "https://services.nvd.nist.gov/rest/json/cve/1.0/{}?addOns=dictionaryCpes"
    LOGGER = LOGGER.getChild("DB")

    def __init__(
        self,
        cachedir: str | None = None,
        backup_cachedir: str | None = None,
        imagedir: str | None = None,
        redhat_api: str | None = None,
        nvd_api: str | None = None,
        report_file: str | None = None,
        service_name: str | None = None,
        session: RateLimiter | None = None
    ) -> None:
        #   Path setup
        self.cachedir: str = cachedir if cachedir is not None else self.CACHE_DIR
        self.backup_cachedir: str = backup_cachedir if backup_cachedir is not None else self.BACKUP_CACHE_DIR
        self.dbpath: str = os.path.join(self.cachedir, DB_NAME)
        self.imagedir: str = imagedir if imagedir is not None else self.IMAGE_DIR

        #   API setup
        self.redhat_api: str = redhat_api if redhat_api is not None else self.REDHAT_API
        self.nvd_api: str = nvd_api if nvd_api is not None else self.NVD_API

        #   DB setup
        self.con: sqlite3.Connection | None = None

        #   Report file
        self.report_file: str = report_file if report_file is not None else ""
        self.service_name: str = service_name if service_name is not None else "service"

        #   Process
        self.session = session

        #   Data holding.
        self.cve_list = []
        self.all_cve_entries: list[dict[str, Any]] | None = None

    def check_db_exists(self) -> None:
        #   Checks the database file exists
        if not os.path.exists(self.cachedir):
            self.LOGGER.info(
                f"Database {DB_NAME} not found from .cache, start creating one")
            os.makedirs(self.cachedir)
            subprocess.run(["sqlite3", self.dbpath, "VACUUM"])
            self.init_database()
        else:
            if not os.path.exists(self.dbpath):
                self.LOGGER.info(
                    f"Database {DB_NAME} not found from .cache, start creating one")
                subprocess.run(["sqlite3", self.dbpath, "VACUUM"])
                self.init_database()

    def init_database(self) -> None:
        #   Create tables if not exists
        self.db_open()
        cur = self.con.cursor()

        #   Queries
        cve_table_create = """
            CREATE TABLE IF NOT EXISTS cve (
                cve_id TEXT,
                severity TEXT,
                description TEXT,
                score INTEGER,
                exploitability_score INTEGER,
                impact_score INTEGER,
                cvss_version INTEGER,
                cvss_vector TEXT,
                service TEXT,
                scan_date,
                PRIMARY KEY(cve_id)
            )
        """
        range_table_create = """
            CREATE TABLE IF NOT EXISTS cve_range (
                cve_id TEXT,
                vendor TEXT,
                product TEXT,
                version TEXT,
                versionStartIncluding TEXT,
                versionStartExcluding TEXT,
                versionEndIncluding TEXT,
                versionEndExcluding TEXT,
                service TEXT,
                scan_date TEXT,
                FOREIGN KEY(cve_id) REFERENCES cve(cve_id)
            )
        """
        index_range_query = """
            CREATE INDEX IF NOT EXISTS product_index ON cve_range (cve_id, vendor, product) 
        """
        reference_table_create = """
            CREATE TABLE IF NOT EXISTS reference (
                cve_id TEXT,
                url TEXT,
                name TEXT,
                resource TEXT,
                service TEXT,
                scan_date TEXT,
                FOREIGN KEY(cve_id) REFERENCES cve(cve_id)
            ) 
        """
        index_reference_range_query = """
            CREATE INDEX IF NOT EXISTS reference_index ON reference (cve_id, url, name)
        """

        #   Execute the queries
        cur.execute(cve_table_create)
        cur.execute(range_table_create)
        cur.execute(index_range_query)
        cur.execute(reference_table_create)
        cur.execute(index_reference_range_query)
        self.con.commit()

    def db_open(self) -> None:
        #   Open the connection to the database
        if not self.con:
            self.con = sqlite3.connect(self.dbpath)

    def db_close(self) -> None:
        #   Close the connection to the database
        if self.con:
            self.con.close()
            self.con = None

    async def session_open(self) -> None:
        #   Init the request module
        if not self.session:
            con = aiohttp.TCPConnector(limit_per_host=19)
            self.session = RateLimiter(
                aiohttp.ClientSession(connector=con, trust_env=True)
            )

    async def session_close(self) -> None:
        #   Close the connection
        await self.session.close()
        self.session = None

    async def run_report(self) -> None:
        await self.session_open()

        report = Report(
            logger=self.LOGGER,
            report_file=self.report_file,
            service_name=self.service_name,
            nvd_api=self.nvd_api,
            session=self.session)

        self.cve_list = report.scan_cve()

        if len(self.cve_list) > 0:
            #   Fetches the CVEs to the NVD API
            self.LOGGER.info("Start scanning the report file...")
            self.all_cve_entries = await report.get()

        await self.session_close()

    def find_cve_exists(self, cve: str, cur: sqlite3.Cursor | None = None) -> bool:
        #   Find the existing CVE in the database
        query = """
            SELECT EXISTS(SELECT 1 FROM cve WHERE cve_id="{}") 
        """.format(cve)

        row = cur.execute(query).fetchone()

        return True if row[0] == 1 else False

    def parse_node(self, node: dict[str, Any]) -> list[dict[str, str]]:
        affects_list = []
        if "cpe_match" in node:
            for cpe_match in node["cpe_match"]:
                cpe_split = cpe_match["cpe23Uri"].split(":")
                affects = {
                    "vendor": cpe_split[3],
                    "product": cpe_split[4],
                    "version": cpe_split[5]
                }

                range_fields = [
                    "versionStartIncluding",
                    "versionStartExcluding",
                    "versionEndIncluding",
                    "versionEndExcluding"
                ]

                for field in range_fields:
                    if field in cpe_match:
                        affects[field] = cpe_match[field]
                    else:
                        affects[field] = ""

                affects_list.append(affects)

        return affects_list

    def parse_reference(self, reference: dict[str, Any]) -> list[dict[str, str]]:
        references_list = []
        if "url" in reference:
            ref = {
                "url": reference["url"],
                "name": reference["name"],
                "source": reference["refsource"]
            }

            references_list.append(ref)
        return references_list

    def populate_cve_list(
        self,
        cve_insert: str,
        cve_range_insert: str,
        del_cve_range: str,
        reference_insert: str,
        cur: sqlite3.Cursor,
    ) -> None:

        #   Start inserting to database
        for cve_item in self.all_cve_entries:
            if not self.find_cve_exists(
                    cve_item["cve"]["CVE_data_meta"]["ID"], cur):

                cve = {
                    "cve_id": cve_item["cve"]["CVE_data_meta"]["ID"],
                    "description": cve_item["cve"]["description"]["description_data"][0]["value"],
                    "severity": "unknown",
                    "score": "unknown",
                    "exploitability_score": "unknown",
                    "impact_score": "unknown",
                    "CVSS_version": "unknown",
                    "CVSS_vector": "unknown",
                    "service": self.service_name,
                    "scan_date": get_cur_date()
                }

                if cve["description"].startswith("** REJECT **"):
                    #   Skip this CVE if it's marked as 'REJECT'
                    continue

                #   Get CVSSv3 or CVSSv2 score for output
                if "baseMetricV3" in cve_item["impact"]:
                    cve["severity"] = cve_item["impact"]["baseMetricV3"]["cvssV3"]["baseSeverity"]
                    cve["score"] = cve_item["impact"]["baseMetricV3"]["cvssV3"]["baseScore"]
                    cve["exploitability_score"] = cve_item["impact"]["baseMetricV3"]["exploitabilityScore"]
                    cve["impact_score"] = cve_item["impact"]["baseMetricV3"]["impactScore"]
                    cve["CVSS_vector"] = cve_item["impact"]["baseMetricV3"]["cvssV3"]["vectorString"]
                    cve["CVSS_version"] = 3
                elif "bsaeMetricV2" in cve_item["impact"]:
                    cve["severity"] = cve_item["impact"]["baseMetricV2"]["severity"]
                    cve["score"] = cve_item["impact"]["baseMetricV2"]["cvssV2"]["baseScore"]
                    cve["exploitability_score"] = cve_item["impact"]["baseMetricV2"]["exploitabilityScore"]
                    cve["impact_score"] = cve_item["impact"]["baseMetricV2"]["impactScore"]
                    cve["CVSS_vector"] = cve_item["impact"]["baseMetricV2"]["cvssV2"]["vectorString"]
                    cve["CVSS_version"] = 2

                cur.execute(
                    cve_insert,
                    [
                        cve["cve_id"],
                        cve["description"],
                        cve["severity"],
                        cve["score"],
                        cve["exploitability_score"],
                        cve["impact_score"],
                        cve["CVSS_version"],
                        cve["CVSS_vector"],
                        cve["service"],
                        cve["scan_date"]
                    ]
                )

                #   Delete any old range entries
                cur.execute(del_cve_range, (cve["cve_id"], ))

                #   Iterate the nodes with version data
                affects_list = []
                if "configurations" in cve_item:
                    for node in cve_item["configurations"]["nodes"]:
                        affects_list.extend(self.parse_node(node))
                        if "children" in node:
                            for child in node["children"]:
                                affects_list.extend(self.parse_node(child))
                cur.executemany(
                    cve_range_insert,
                    [
                        (
                            cve["cve_id"],
                            affected["vendor"],
                            affected["product"],
                            affected["version"],
                            affected["versionStartIncluding"],
                            affected["versionStartExcluding"],
                            affected["versionEndIncluding"],
                            affected["versionEndExcluding"],
                            self.service_name,
                            get_cur_date()
                        )
                        for affected in affects_list
                    ]
                )

                #   Iterate the reference with references data
                references_list = []
                if "references" in cve_item["cve"]:
                    for reference in cve_item["cve"]["references"]["reference_data"]:
                        references_list.extend(self.parse_reference(reference))

                cur.executemany(
                    reference_insert,
                    [
                        (
                            cve["cve_id"],
                            ref["url"],
                            ref["name"],
                            ref["source"],
                            self.service_name,
                            get_cur_date()
                        )
                        for ref in references_list
                    ]
                )

    def populate_db(self) -> None:
        #   Query insert the database
        self.db_open()
        cur = self.con.cursor()

        #   Query commands
        cve_insert = """
            INSERT INTO cve (
                cve_id,
                description,
                severity,
                score,
                exploitability_score,
                impact_score,
                cvss_version,
                cvss_vector,
                service,
                scan_date
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        cve_range_insert = """
            INSERT or REPLACE INTO cve_range (
                cve_id,
                vendor,
                product,
                version,
                versionStartIncluding,
                versionStartExcluding,
                versionEndIncluding,
                versionEndExcluding,
                service,
                scan_date
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        del_cve_range = """
            DELETE FROM cve_range WHERE cve_id=? 
        """
        reference_insert = """
            INSERT INTO reference (
                cve_id,
                url,
                name,
                resource,
                service,
                scan_date
            ) VALUES (?, ?, ?, ?, ?, ?)
        """

        if len(self.all_cve_entries) > 0:
            self.populate_cve_list(cve_insert=cve_insert,
                                   cve_range_insert=cve_range_insert,
                                   del_cve_range=del_cve_range,
                                   reference_insert=reference_insert,
                                   cur=cur)
            self.con.commit()

        self.db_close()

    def process_report_file(self) -> None:
        self.LOGGER.debug(
            "Start scanning the report file event from dependency-check")

        #   Loop the event
        run_coroutine(self.run_report())

        self.populate_db()

    def process_plot_cve(self) -> None:
        self.LOGGER.debug("Start plotting the latest CVE database")

        #   Check the Image exists
        if not os.path.exists(self.imagedir):
            self.LOGGER.info("Directory plot not found, start creating one")
            os.makedirs(self.imagedir)
