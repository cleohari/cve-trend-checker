#   Copyright (C) 2022 MIT
#   Author: Kha Tran
#   Title: Fresher Software Engineer


"""
    CVE Trend Checker's Databae System source code
"""
from __future__ import annotations
from asyncio import subprocess


import aiohttp
import logging
import os
import sqlite3
import subprocess

from typing import Any

from async_p import RateLimiter, run_coroutine
from date import get_cur_date, get_cur_date_non_iso, get_cur_month
from error import ErrorHandler, ErrorMode
from key import Keyword
from log import LOGGER
from report import Report
from visual import Visual


logging.basicConfig(level=logging.DEBUG)


#   Database PATH locations
DATABASE_LOCATION_DEFAULT: str = os.path.join(
    os.path.expanduser("~"), ".cache", "ctc-database")
DATABASE_LOCATION_BACKUP: str = os.path.join(
    os.path.expanduser("~"), ".cache", "ctc-backup")
DB_NAME: str = "scan.db"
IMAGE_LOCATION_DEFAULT: str = os.path.join(os.path.dirname(
    os.path.abspath(__file__)), "plot", get_cur_date_non_iso())


class DB:
    """
        Scans from report files and fetch each CVE from APIs
    """

    CACHE_DIR: str = DATABASE_LOCATION_DEFAULT
    BACKUP_CACHE_DIR: str = DATABASE_LOCATION_BACKUP
    IMAGE_DIR: str = IMAGE_LOCATION_DEFAULT
    REDHAT_API: str = "https://access.redhat.com/hydra/rest/securitydata/cve/{}.json"
    NVD_API: str = "https://services.nvd.nist.gov/rest/json/cve/1.0/{}?addOns=dictionaryCpes"
    LOGGER = LOGGER.getChild("DB")

    def __init__(
        self,
        cachedir: str | None = None,
        backup_cachedir: str | None = None,
        imagedir: str | None = None,
        redhat_api: str | None = None,
        nvd_api: str | None = None,
        report_file: str | None = None,
        service_name: str | None = None,
        session: RateLimiter | None = None
    ) -> None:
        #   Path setup
        self.cachedir: str = cachedir if cachedir is not None else self.CACHE_DIR
        self.backup_cachedir: str = backup_cachedir if backup_cachedir is not None else self.BACKUP_CACHE_DIR
        self.dbpath: str = os.path.join(self.cachedir, DB_NAME)
        self.imagedir: str = imagedir if imagedir is not None else self.IMAGE_DIR

        #   API setup
        self.redhat_api: str = redhat_api if redhat_api is not None else self.REDHAT_API
        self.nvd_api: str = nvd_api if nvd_api is not None else self.NVD_API

        #   DB setup
        self.con: sqlite3.Connection | None = None

        #   Report file
        self.report_file: str = report_file if report_file is not None else ""
        self.service_name: str = service_name if service_name is not None else ""

        #   Process
        self.session = session

        #   Data holding.
        self.cve_list = []
        self.all_cve_entries: list[dict[str, Any]] | None = None

        #   Utilities
        self.visual: Visual = None

    def check_db_exists(self) -> None:
        #   Checks the database file exists
        if not os.path.exists(self.cachedir):
            self.LOGGER.info(
                f"Database {DB_NAME} not found from .cache, start creating one")
            os.makedirs(self.cachedir)
            subprocess.run(["sqlite3", self.dbpath, "VACUUM"])
            self.init_database()
        else:
            if not os.path.exists(self.dbpath):
                self.LOGGER.info(
                    f"Database {DB_NAME} not found from .cache, start creating one")
                subprocess.run(["sqlite3", self.dbpath, "VACUUM"])
                self.init_database()

    def init_database(self) -> None:
        #   Create tables if not exists
        self.db_open()
        cur = self.con.cursor()

        #   Queries
        cve_table_create = """
            CREATE TABLE IF NOT EXISTS cve (
                cve_id TEXT,
                severity TEXT,
                description TEXT,
                score INTEGER,
                exploitability_score INTEGER,
                impact_score INTEGER,
                cvss_version INTEGER,
                cvss_vector TEXT,
                PRIMARY KEY(cve_id)
            )
        """
        range_table_create = """
            CREATE TABLE IF NOT EXISTS cve_range (
                cve_id TEXT,
                vendor TEXT,
                product TEXT,
                version TEXT,
                versionStartIncluding TEXT,
                versionStartExcluding TEXT,
                versionEndIncluding TEXT,
                versionEndExcluding TEXT,
                FOREIGN KEY(cve_id) REFERENCES cve(cve_id)
            )
        """
        index_range_query = """
            CREATE INDEX IF NOT EXISTS product_index ON cve_range (cve_id, vendor, product)
        """
        track_table_create = """
            CREATE TABLE IF NOT EXISTS track (
                cve_id TEXT,
                service TEXT,
                date TEXT,
                status TEXT,
                FOREIGN KEY(cve_id) REFERENCES cve(cve_id)
            ) 
        """
        index_track_query = """
            CREATE INDEX IF NOT EXISTS track_index ON track(cve_id, service, date, status) 
        """
        reference_table_create = """
            CREATE TABLE IF NOT EXISTS reference (
                cve_id TEXT,
                url TEXT,
                name TEXT,
                resource TEXT,
                service TEXT,
                scan_date TEXT,
                FOREIGN KEY(cve_id) REFERENCES cve(cve_id)
            )
        """
        index_reference_query = """
            CREATE INDEX IF NOT EXISTS reference_index ON reference (cve_id, url, name)
        """
        key_table_create = """
            CREATE TABLE IF NOT EXISTS key (
                cve_id TEXT,
                key TEXT,
                service TEXT,
                scan_date TEXT,
                scan_month TEXT,
                FOREIGN KEY(cve_id) REFERENCES cve(cve_id)
            )
        """
        index_key_query = """
            CREATE INDEX IF NOT EXISTS key_index ON key(cve_id, key)
        """

        #   Execute the queries
        cur.execute(cve_table_create)
        cur.execute(range_table_create)
        cur.execute(index_range_query)
        cur.execute(track_table_create)
        cur.execute(index_track_query)
        cur.execute(reference_table_create)
        cur.execute(index_reference_query)
        cur.execute(key_table_create)
        cur.execute(index_key_query)
        self.con.commit()

    def db_open(self) -> None:
        #   Open the connection to the database
        if not self.con:
            self.con = sqlite3.connect(self.dbpath)

    def db_close(self) -> None:
        #   Close the connection to the database
        if self.con:
            self.con.close()
            self.con = None

    async def session_open(self) -> None:
        #   Init the request module
        if not self.session:
            con = aiohttp.TCPConnector(limit_per_host=19)
            self.session = RateLimiter(
                aiohttp.ClientSession(connector=con, trust_env=True)
            )

    async def session_close(self) -> None:
        #   Close the connection
        await self.session.close()
        self.session = None

    async def run_report(self) -> None:
        await self.session_open()

        report = Report(
            logger=self.LOGGER,
            report_file=self.report_file,
            service_name=self.service_name,
            nvd_api=self.nvd_api,
            session=self.session)

        self.cve_list = report.scan_cve()

        if len(self.cve_list) > 0:
            #   Fetches the CVEs to the NVD API
            self.LOGGER.info("Start scanning the report file...")
            self.all_cve_entries = await report.get()

        await self.session_close()

    def find_cve_exists(self, cve: str, table: str, cur: sqlite3.Cursor | None = None) -> bool:
        #   Find the existing CVE in the database
        query = f"""
            SELECT EXISTS(SELECT 1 FROM {table} WHERE cve_id="{cve}")
        """

        row = cur.execute(query).fetchone()

        return True if row[0] == 1 else False

    def parse_node(self, node: dict[str, Any]) -> list[dict[str, str]]:
        affects_list = []
        if "cpe_match" in node:
            for cpe_match in node["cpe_match"]:
                cpe_split = cpe_match["cpe23Uri"].split(":")
                affects = {
                    "vendor": cpe_split[3],
                    "product": cpe_split[4],
                    "version": cpe_split[5]
                }

                range_fields = [
                    "versionStartIncluding",
                    "versionStartExcluding",
                    "versionEndIncluding",
                    "versionEndExcluding"
                ]

                for field in range_fields:
                    if field in cpe_match:
                        affects[field] = cpe_match[field]
                    else:
                        affects[field] = ""

                affects_list.append(affects)

        return affects_list

    def parse_reference(self, reference: dict[str, Any]) -> list[dict[str, str]]:
        references_list = []
        if "url" in reference:
            ref = {
                "url": reference["url"],
                "name": reference["name"],
                "source": reference["refsource"]
            }

            references_list.append(ref)
        return references_list

    def populate_track_table(self, cve_id: str, track_insert: str, cur: sqlite3.Cursor):
        #   Process the Scan Table System
        cur.execute(
            track_insert,
            [
                cve_id,
                self.service_name,
                get_cur_date(),
                "UNSOLVED"
            ]
        )

    def populate_cve_list(
        self,
        cve_insert: str,
        cve_range_insert: str,
        del_cve_range: str,
        reference_insert: str,
        key_insert: str,
        track_insert: str,
        cur: sqlite3.Cursor,
    ) -> None:

        latest_service_records = """
            SELECT cve_id
            FROM track
            WHERE date = (
                SELECT MAX(date)
                FROM track
            )
            AND status = "UNSOLVED"
        """
        raw_records = cur.execute(
            latest_service_records).fetchall()
        records = []
        for r in raw_records:
            records.append(r[0])

        #   Start inserting to database
        for cve_item in self.all_cve_entries:
            #   Create a CVE template format for later to be injected
            cve = {
                "cve_id": cve_item["cve"]["CVE_data_meta"]["ID"],
                "description": cve_item["cve"]["description"]["description_data"][0]["value"],
                "severity": "unknown",
                "score": "unknown",
                "exploitability_score": "unknown",
                "impact_score": "unknown",
                "CVSS_version": "unknown",
                "CVSS_vector": "unknown"
            }

            if cve["description"].startswith("** REJECT **"):
                #   Skip this CVE if it's marked as 'REJECT'
                continue

            #   Check if the cve exists in the latest records
            if cve["cve_id"] in records:
                records.remove(cve["cve_id"])

            #   Get CVSSv3 or CVSSv2 score for output
            if "baseMetricV3" in cve_item["impact"]:
                cve["severity"] = cve_item["impact"]["baseMetricV3"]["cvssV3"]["baseSeverity"]
                cve["score"] = cve_item["impact"]["baseMetricV3"]["cvssV3"]["baseScore"]
                cve["exploitability_score"] = cve_item["impact"]["baseMetricV3"]["exploitabilityScore"]
                cve["impact_score"] = cve_item["impact"]["baseMetricV3"]["impactScore"]
                cve["CVSS_vector"] = cve_item["impact"]["baseMetricV3"]["cvssV3"]["vectorString"]
                cve["CVSS_version"] = 3
            elif "bsaeMetricV2" in cve_item["impact"]:
                cve["severity"] = cve_item["impact"]["baseMetricV2"]["severity"]
                cve["score"] = cve_item["impact"]["baseMetricV2"]["cvssV2"]["baseScore"]
                cve["exploitability_score"] = cve_item["impact"]["baseMetricV2"]["exploitabilityScore"]
                cve["impact_score"] = cve_item["impact"]["baseMetricV2"]["impactScore"]
                cve["CVSS_vector"] = cve_item["impact"]["baseMetricV2"]["cvssV2"]["vectorString"]
                cve["CVSS_version"] = 2

            #   If the cve is new, insert into new CVE Table
            if not self.find_cve_exists(
                    cve_item["cve"]["CVE_data_meta"]["ID"], "cve", cur):
                cur.execute(
                    cve_insert,
                    [
                        cve["cve_id"],
                        cve["description"],
                        cve["severity"],
                        cve["score"],
                        cve["exploitability_score"],
                        cve["impact_score"],
                        cve["CVSS_version"],
                        cve["CVSS_vector"]
                    ]
                )

                #   Delete any old range entries
                cur.execute(del_cve_range, (cve["cve_id"], ))

                #   Iterate the nodes with version data
                affects_list = []
                if "configurations" in cve_item:
                    for node in cve_item["configurations"]["nodes"]:
                        affects_list.extend(self.parse_node(node))
                        if "children" in node:
                            for child in node["children"]:
                                affects_list.extend(self.parse_node(child))
                cur.executemany(
                    cve_range_insert,
                    [
                        (
                            cve["cve_id"],
                            affected["vendor"],
                            affected["product"],
                            affected["version"],
                            affected["versionStartIncluding"],
                            affected["versionStartExcluding"],
                            affected["versionEndIncluding"],
                            affected["versionEndExcluding"]
                        )
                        for affected in affects_list
                    ]
                )

                #   Iterate the reference with references data
                references_list = []
                if "references" in cve_item["cve"]:
                    for reference in cve_item["cve"]["references"]["reference_data"]:
                        references_list.extend(self.parse_reference(reference))

                cur.executemany(
                    reference_insert,
                    [
                        (
                            cve["cve_id"],
                            ref["url"],
                            ref["name"],
                            ref["source"],
                            self.service_name,
                            get_cur_date()
                        )
                        for ref in references_list
                    ]
                )
            #   Insert the values into the Scan Table
            self.populate_track_table(
                cve_id=cve["cve_id"], track_insert=track_insert, cur=cur)

            #   Find the keywords that match with the given description
            keyword = Keyword(content=cve["description"])
            keyword.find_keys()
            keys = keyword.find_list()

            if isinstance(keys, list):
                cur.executemany(
                    key_insert,
                    [
                        (
                            cve["cve_id"],
                            k,
                            self.service_name,
                            get_cur_date(),
                            get_cur_month()
                        )
                        for k in keys
                    ]
                )

        #   Process the solved cve
        for r in records:
            cur.execute(
                track_insert,
                [
                    r,
                    self.service_name,
                    get_cur_date(),
                    "SOLVED"
                ]
            )

    def populate_db(self) -> None:
        #   Query insert the database
        self.db_open()
        cur = self.con.cursor()

        #   Query commands
        cve_insert = """
            INSERT INTO cve (
                cve_id,
                description,
                severity,
                score,
                exploitability_score,
                impact_score,
                cvss_version,
                cvss_vector
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        cve_range_insert = """
            INSERT or REPLACE INTO cve_range (
                cve_id,
                vendor,
                product,
                version,
                versionStartIncluding,
                versionStartExcluding,
                versionEndIncluding,
                versionEndExcluding
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        del_cve_range = """
            DELETE FROM cve_range WHERE cve_id=? 
        """
        track_insert = """
            INSER INTO track (
                cve_id,

            ) 
        """
        track_insert = """
            INSERT INTO track (
                cve_id,
                service,
                date,
                status
            ) VALUES (?, ?, ?, ?)
        """
        reference_insert = """
            INSERT INTO reference (
                cve_id,
                url,
                name,
                resource,
                service,
                scan_date
            ) VALUES (?, ?, ?, ?, ?, ?)
        """
        key_insert = """
            INSERT INTO key (
                cve_id,
                key,
                service,
                scan_date,
                scan_month
            ) VALUES (?, ?, ?, ?, ?)
        """

        if len(self.all_cve_entries) > 0:
            self.populate_cve_list(cve_insert=cve_insert,
                                   cve_range_insert=cve_range_insert,
                                   del_cve_range=del_cve_range,
                                   reference_insert=reference_insert,
                                   key_insert=key_insert,
                                   track_insert=track_insert,
                                   cur=cur)
            self.con.commit()

        self.db_close()

    def process_report_file(self) -> None:
        #   Read the report file
        if self.report_file != "":
            self.LOGGER.debug(
                "Start scanning the report file event from dependency-check")

            #   Loop the event
            run_coroutine(self.run_report())

            self.populate_db()

    def plot_by_config(self, config: dict[str, str] | str) -> None:
        #   Plot bases on the configuration

        self.db_open()
        visual = Visual(con=self.con, logger=self.LOGGER,
                        imagedir=self.imagedir, service_name=config["name"])

        if config["track"]:
            visual.plot_by_tracking()
        if config["latest"]:
            visual.plot_by_latest()

    def process_plot_cve(self, config) -> None:
        #   Plotting handler system

        #   Check the image folder exists
        if not os.path.exists(self.imagedir):
            self.LOGGER.info("plot directory not found, create one by default")
            os.makedirs(self.imagedir)

        self.plot_by_config(config=config)
