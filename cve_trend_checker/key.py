#   Copyright (C) 2022 MIT License
#   Author: Kha Tran
#   Title: Fresher Software Engineer


"""
    Keyword Finding System for CVE Trend Checker source code
"""
from __future__ import annotations


from logging import Logger

from log import LOGGER

#   CVE Key suits data
KEY_SUITS = {
    "Race Condition": ["race", "racy"],
    "Buffer Overflow": ["buffer", "overflow", "stack"],
    "Integer Overflow": ["integer", "overflow", "sinedness", "widthness", "underflow"],
    "Improper Access": ["improper", "unauthenticated", "gain access", "permission"],
    "Cross Site Scripting": ["cross site", "cross site scripting", "css", "xss", "htmlspecialchar", "php only"],
    "Denial of Service": ["denial service", "denial of service", "dos", "crash", "prototype pollution"],
    "Deadlock": ["dead lock", "deadlock"],
    "SQL Injection": ["sql", "sqli", "injection"],
    "Format String": ["format", "string", "format string", "printf", "scanf"],
    "Cross Site Request Forgery": ["cross site", "cross site request", "cross site request forgery", "request forgery", "csrf", "xsrf", "forged"],
    "Privilege Escalation": ["privilege", "escalation", "escalate", "privilege escalation"],
    "Authentication": ["transport layer security", "transport layer", "layer security", "transport"]
}

#   CVE description content template
FOO_CONTENT = [
    "In Async before 2.6.4 and 3.x before 3.2.2, a malicious user can obtain privileges via the mapValues() method, aka lib/internal/iterator.js createObjectIterator prototype pollution.",
    "A UNIX Symbolic Link (Symlink) Following vulnerability in the systemd service file for watchman of openSUSE Backports SLE-15-SP3, Factory allows local attackers to escalate to root. This issue affects: openSUSE Backports SLE-15-SP3 watchman versions prior to 4.9.0. openSUSE Factory watchman versions prior to 4.9.0-9.1.",
    "Minimist <=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69-95).",
    "Forge (also called `node-forge`) is a native implementation of Transport Layer Security in JavaScript. Prior to version 1.3.0, RSA PKCS#1 v1.5 signature verification code does not check for tailing garbage bytes after decoding a `DigestInfo` ASN.1 structure. This can allow padding bytes to be removed and garbage data added to forge a signature when a low public exponent is being used. The issue has been addressed in `node-forge` version 1.3.0. There are currently no known workarounds.",
    "Forge (also called `node-forge`) is a native implementation of Transport Layer Security in JavaScript. Prior to version 1.3.0, RSA PKCS#1 v1.5 signature verification code is lenient in checking the digest algorithm structure. This can allow a crafted structure that steals padding bytes and uses unchecked portion of the PKCS#1 encoded message to forge a signature when a low public exponent is being used. The issue has been addressed in `node-forge` version 1.3.0. There are currently no known workarounds.",
    "Forge (also called `node-forge`) is a native implementation of Transport Layer Security in JavaScript. Prior to version 1.3.0, RSA PKCS#1 v1.5 signature verification code does not properly check `DigestInfo` for a proper ASN.1 structure. This can lead to successful verification with signatures that contain invalid structures but a valid digest. The issue has been addressed in `node-forge` version 1.3.0. There are currently no known workarounds."
]


class Keyword:
    """
        Finding Keywords class in description and other stuffs. 
    """

    KEYS = KEY_SUITS

    def __init__(
        self,
        logger: Logger = LOGGER.getChild("Keyword"),
        content: str | None = None,
        keys: dict[str, list] | None = None
    ) -> None:
        #   Logging systems
        self.logger = logger or LOGGER.getChild(__class__.__name__)

        #   Contents
        self.content: str = content if content is not None else ""
        self.parsed_content: str = ""

        #   Key suits
        self.keys: dict[str, list] = keys if keys is not None else self.KEYS
        self.found_keys: dict[str, list] = {}

        #   Parsing the content by default
        if content:
            self.parse_content()

    def parse_content(self) -> None:
        #   Parses the content
        translation_table = dict.fromkeys(
            map(ord, "!@#$,\/().`'"), None)
        self.parsed_content = self.content.translate(translation_table).lower()

    def find_trusted(self) -> str:
        mentioned = 0
        trusted = ""
        #   Find the most trusted keyword that is close or matched with the given CVE
        for key, val in self.found_keys.items():
            if len(val) > mentioned:
                trusted = key
                mentioned = len(val)
        return trusted

    def find_list(self) -> list:
        #   Simply returns the list of keyword in CVE
        trusted_list = []
        for key in self.found_keys:
            trusted_list.append(key)
        return trusted_list

    def find_keys(self) -> None:
        #   Finds the set of keys
        for key in self.keys:
            for v in self.keys[key]:
                if v in self.parsed_content:
                    if key not in self.found_keys:
                        self.found_keys[key] = []
                        self.found_keys[key].append(v)
                    else:
                        self.found_keys[key].append(v)
